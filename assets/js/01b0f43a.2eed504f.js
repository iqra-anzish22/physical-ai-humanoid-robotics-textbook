"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[594],{53:(e,n,i)=>{function a(e){var n,i,t="";if("string"==typeof e||"number"==typeof e)t+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(i=a(e[n]))&&(t&&(t+=" "),t+=i);else for(n in e)e[n]&&(t&&(t+=" "),t+=n);return t}i.d(n,{A:()=>t});const t=function(){for(var e,n,i=0,t="";i<arguments.length;)(e=arguments[i++])&&(n=a(e))&&(t&&(t+=" "),t+=n);return t}},5478:(e,n,i)=>{i.r(n),i.d(n,{contentTitle:()=>s,default:()=>y,frontMatter:()=>l,metadata:()=>r,toc:()=>m});var a=i(8168),t=(i(6540),i(5680)),o=i(6515);const l={title:"Simulation Concepts and Physics",sidebar_position:2,description:"Core concepts of robotics simulation with focus on physics modeling",keywords:["simulation","physics","gazebo","unity","robotics","physical ai"],learning_outcomes:["Understand fundamental simulation concepts and physics modeling","Configure realistic physics parameters in simulation environments","Implement sensor models and their limitations","Evaluate simulation fidelity for robotics applications"]},s="Simulation Concepts and Physics",r={unversionedId:"gazebo-unity/simulation",id:"gazebo-unity/simulation",isDocsHomePage:!1,title:"Simulation Concepts and Physics",description:"Core concepts of robotics simulation with focus on physics modeling",source:"@site/docs/gazebo-unity/simulation.md",sourceDirName:"gazebo-unity",slug:"/gazebo-unity/simulation",permalink:"/physical-ai-humanoid-robotics-textbook/gazebo-unity/simulation",editUrl:"https://github.com/iqra-anzish22/physical-ai-humanoid-robotics-textbook/edit/main/docs/gazebo-unity/simulation.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Simulation Concepts and Physics",sidebar_position:2,description:"Core concepts of robotics simulation with focus on physics modeling",keywords:["simulation","physics","gazebo","unity","robotics","physical ai"],learning_outcomes:["Understand fundamental simulation concepts and physics modeling","Configure realistic physics parameters in simulation environments","Implement sensor models and their limitations","Evaluate simulation fidelity for robotics applications"]},sidebar:"textbookSidebar",previous:{title:"Gazebo & Unity Simulation",permalink:"/physical-ai-humanoid-robotics-textbook/gazebo-unity/index"},next:{title:"Gazebo & Unity Examples",permalink:"/physical-ai-humanoid-robotics-textbook/gazebo-unity/examples"}},m=[{value:"Introduction to Simulation Physics",id:"introduction-to-simulation-physics",children:[{value:"Core Physics Concepts",id:"core-physics-concepts",children:[]}]},{value:"Physics Engines in Simulation",id:"physics-engines-in-simulation",children:[{value:"Open Dynamics Engine (ODE)",id:"open-dynamics-engine-ode",children:[]},{value:"Bullet Physics",id:"bullet-physics",children:[]},{value:"Simbody",id:"simbody",children:[]}]},{value:"Gazebo Physics Configuration",id:"gazebo-physics-configuration",children:[{value:"World File Setup",id:"world-file-setup",children:[]},{value:"Physics Parameters",id:"physics-parameters",children:[]},{value:"Model Configuration",id:"model-configuration",children:[]}]},{value:"Unity Physics System",id:"unity-physics-system",children:[{value:"Rigidbody Component",id:"rigidbody-component",children:[]},{value:"Physics Materials",id:"physics-materials",children:[]}]},{value:"Sensor Simulation",id:"sensor-simulation",children:[{value:"Camera Sensors",id:"camera-sensors",children:[]},{value:"LIDAR Simulation",id:"lidar-simulation",children:[]},{value:"IMU Simulation",id:"imu-simulation",children:[]}]},{value:"Simulation Fidelity Considerations",id:"simulation-fidelity-considerations",children:[{value:"Visual Fidelity",id:"visual-fidelity",children:[]},{value:"Physics Fidelity",id:"physics-fidelity",children:[]},{value:"Sensor Fidelity",id:"sensor-fidelity",children:[]}]},{value:"Domain Randomization",id:"domain-randomization",children:[]},{value:"Performance Optimization",id:"performance-optimization",children:[{value:"Level of Detail (LOD)",id:"level-of-detail-lod",children:[]},{value:"Parallel Processing",id:"parallel-processing",children:[]}]},{value:"Quality Assessment",id:"quality-assessment",children:[{value:"Simulation Quality Metrics",id:"simulation-quality-metrics",children:[]},{value:"Validation Techniques",id:"validation-techniques",children:[]}]},{value:"Summary",id:"summary",children:[]},{value:"References",id:"references",children:[]}],c={toc:m},u="wrapper";function y({components:e,...n}){return(0,t.yg)(u,(0,a.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"simulation-concepts-and-physics"},"Simulation Concepts and Physics"),(0,t.yg)(o.A,{outcomes:["Understand fundamental simulation concepts and physics modeling","Configure realistic physics parameters in simulation environments","Implement sensor models and their limitations","Evaluate simulation fidelity for robotics applications"],mdxType:"LearningOutcome"}),(0,t.yg)("h2",{id:"introduction-to-simulation-physics"},"Introduction to Simulation Physics"),(0,t.yg)("p",null,"Simulation physics in robotics involves modeling the physical laws that govern how objects move, interact, and respond to forces in virtual environments. The goal is to create simulations that accurately reflect real-world physics while remaining computationally efficient."),(0,t.yg)("h3",{id:"core-physics-concepts"},"Core Physics Concepts"),(0,t.yg)("p",null,"The fundamental physics concepts in robotics simulation include:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Rigid body dynamics"),": How solid objects move and interact"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Collision detection"),": Identifying when objects make contact"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Contact response"),": How objects react to collisions"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Constraints and joints"),": Limiting degrees of freedom"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Friction models"),": Simulating surface interactions"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Fluid dynamics"),": Modeling air and liquid interactions (optional)")),(0,t.yg)("h2",{id:"physics-engines-in-simulation"},"Physics Engines in Simulation"),(0,t.yg)("h3",{id:"open-dynamics-engine-ode"},"Open Dynamics Engine (ODE)"),(0,t.yg)("p",null,"ODE is one of the oldest and most widely used physics engines in robotics simulation:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Strengths"),": Stable, well-tested, good for rigid body simulation"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Weaknesses"),": Can be less accurate for complex contacts"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Use cases"),": Mobile robots, manipulators, basic interactions")),(0,t.yg)("h3",{id:"bullet-physics"},"Bullet Physics"),(0,t.yg)("p",null,"Bullet provides more modern physics simulation capabilities:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Strengths"),": Better contact handling, more accurate collisions"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Weaknesses"),": Can be more computationally expensive"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Use cases"),": Complex manipulation, detailed contact simulation")),(0,t.yg)("h3",{id:"simbody"},"Simbody"),(0,t.yg)("p",null,"Simbody is designed for high-fidelity multibody dynamics:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Strengths"),": High accuracy, good for complex articulated systems"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Weaknesses"),": More complex to configure"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Use cases"),": Humanoid robots, complex mechanical systems")),(0,t.yg)("h2",{id:"gazebo-physics-configuration"},"Gazebo Physics Configuration"),(0,t.yg)("h3",{id:"world-file-setup"},"World File Setup"),(0,t.yg)("p",null,"A Gazebo world file defines the physics properties of the simulation environment:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-xml"},"<sdf version='1.6'>\n  <world name='default'>\n    <physics type='ode'>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Models and other elements --\x3e\n  </world>\n</sdf>\n")),(0,t.yg)("h3",{id:"physics-parameters"},"Physics Parameters"),(0,t.yg)("p",null,"Key physics parameters to consider:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Max step size"),": Smaller values increase accuracy but decrease performance"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Real-time factor"),": Ratio of simulation time to real time"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Update rate"),": How frequently physics calculations are performed"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Gravity"),": Usually set to Earth's gravity (9.8 m/s\xb2)")),(0,t.yg)("h3",{id:"model-configuration"},"Model Configuration"),(0,t.yg)("p",null,"Robot models in Gazebo are defined with SDF (Simulation Description Format):"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-xml"},"<model name='my_robot'>\n  <link name='base_link'>\n    <inertial>\n      <mass>1.0</mass>\n      <inertia>\n        <ixx>0.01</ixx>\n        <ixy>0</ixy>\n        <ixz>0</ixz>\n        <iyy>0.01</iyy>\n        <iyz>0</iyz>\n        <izz>0.01</izz>\n      </inertia>\n    </inertial>\n\n    <collision name='collision'>\n      <geometry>\n        <box><size>0.5 0.5 0.5</size></box>\n      </geometry>\n    </collision>\n\n    <visual name='visual'>\n      <geometry>\n        <box><size>0.5 0.5 0.5</size></box>\n      </geometry>\n    </visual>\n  </link>\n</model>\n")),(0,t.yg)("h2",{id:"unity-physics-system"},"Unity Physics System"),(0,t.yg)("p",null,"Unity's physics system is based on the NVIDIA PhysX engine:"),(0,t.yg)("h3",{id:"rigidbody-component"},"Rigidbody Component"),(0,t.yg)("p",null,"The Rigidbody component makes objects subject to physics:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-csharp"},"public class RobotController : MonoBehaviour\n{\n    public Rigidbody rb;\n    public float forceMultiplier = 10f;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n    }\n\n    void FixedUpdate()\n    {\n        // Apply forces for movement\n        rb.AddForce(Vector3.forward * forceMultiplier * Time.deltaTime);\n    }\n}\n")),(0,t.yg)("h3",{id:"physics-materials"},"Physics Materials"),(0,t.yg)("p",null,"Physics materials define surface properties:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-csharp"},"public class SurfaceProperties : MonoBehaviour\n{\n    public PhysicMaterial material;\n\n    void Start()\n    {\n        // Configure friction and bounciness\n        material.staticFriction = 0.5f;\n        material.dynamicFriction = 0.4f;\n        material.bounciness = 0.1f;\n    }\n}\n")),(0,t.yg)("h2",{id:"sensor-simulation"},"Sensor Simulation"),(0,t.yg)("h3",{id:"camera-sensors"},"Camera Sensors"),(0,t.yg)("p",null,"Simulating vision sensors involves rendering from the sensor's perspective:"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Gazebo:")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-xml"},"<sensor name='camera' type='camera'>\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n    </image>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>\n    </noise>\n  </camera>\n</sensor>\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Unity:")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-csharp"},"public class CameraSensor : MonoBehaviour\n{\n    public Camera cam;\n    public int width = 640;\n    public int height = 480;\n\n    void Start()\n    {\n        cam = GetComponent<Camera>();\n        cam.targetTexture = new RenderTexture(width, height, 24);\n    }\n\n    // Add noise simulation\n    void AddNoise()\n    {\n        // Implementation for adding sensor noise\n    }\n}\n")),(0,t.yg)("h3",{id:"lidar-simulation"},"LIDAR Simulation"),(0,t.yg)("p",null,"LIDAR sensors can be simulated using raycasting:"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Gazebo:")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-xml"},"<sensor name='lidar' type='ray'>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>360</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n</sensor>\n")),(0,t.yg)("h3",{id:"imu-simulation"},"IMU Simulation"),(0,t.yg)("p",null,"Inertial Measurement Units can be simulated by calculating accelerations and angular velocities from the physics engine:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},"class IMUSimulator:\n    def __init__(self, noise_params):\n        self.noise_params = noise_params\n        self.previous_pose = None\n\n    def simulate_imu(self, current_pose, dt):\n        # Calculate linear acceleration\n        if self.previous_pose:\n            linear_acc = (current_pose.linear_velocity -\n                         self.previous_pose.linear_velocity) / dt\n            # Add noise\n            linear_acc += np.random.normal(0, self.noise_params['acceleration'], 3)\n\n        # Calculate angular velocity from pose changes\n        angular_vel = self.calculate_angular_velocity(current_pose, dt)\n\n        return {\n            'linear_acceleration': linear_acc,\n            'angular_velocity': angular_vel,\n            'orientation': current_pose.orientation\n        }\n")),(0,t.yg)("h2",{id:"simulation-fidelity-considerations"},"Simulation Fidelity Considerations"),(0,t.yg)("h3",{id:"visual-fidelity"},"Visual Fidelity"),(0,t.yg)("p",null,"Visual fidelity affects perception-based algorithms:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Texture quality"),": High-resolution textures for realistic appearance"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Lighting"),": Accurate lighting models and shadows"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Rendering pipeline"),": Photo-realistic rendering options"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Sensor noise"),": Realistic noise models for cameras")),(0,t.yg)("h3",{id:"physics-fidelity"},"Physics Fidelity"),(0,t.yg)("p",null,"Physics fidelity affects dynamics and control:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Contact modeling"),": Accurate friction and collision response"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Inertial properties"),": Correct mass, center of mass, and moments of inertia"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Actuator models"),": Realistic motor and actuator dynamics"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Flexibility"),": Modeling flexible components when necessary")),(0,t.yg)("h3",{id:"sensor-fidelity"},"Sensor Fidelity"),(0,t.yg)("p",null,"Sensor fidelity affects perception and state estimation:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Noise models"),": Realistic sensor noise and biases"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Latency"),": Simulating sensor processing delays"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Bandwidth"),": Modeling sensor update rates"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Field of view"),": Accurate representation of sensor limitations")),(0,t.yg)("h2",{id:"domain-randomization"},"Domain Randomization"),(0,t.yg)("p",null,"Domain randomization is a technique to improve sim-to-real transfer:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-python"},"class DomainRandomizer:\n    def __init__(self):\n        self.param_ranges = {\n            'friction': (0.3, 0.8),\n            'mass': (0.8, 1.2),\n            'lighting': (0.5, 2.0),\n            'texture': (0, 100)  # Random texture selection\n        }\n\n    def randomize_environment(self):\n        # Randomize physics parameters\n        friction = np.random.uniform(*self.param_ranges['friction'])\n        mass_multiplier = np.random.uniform(*self.param_ranges['mass'])\n\n        # Randomize visual parameters\n        lighting = np.random.uniform(*self.param_ranges['lighting'])\n        texture_id = np.random.randint(*self.param_ranges['texture'])\n\n        return {\n            'friction': friction,\n            'mass_multiplier': mass_multiplier,\n            'lighting': lighting,\n            'texture_id': texture_id\n        }\n")),(0,t.yg)("h2",{id:"performance-optimization"},"Performance Optimization"),(0,t.yg)("h3",{id:"level-of-detail-lod"},"Level of Detail (LOD)"),(0,t.yg)("p",null,"Adjust simulation complexity based on importance:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Collision geometry"),": Use simplified meshes for collision detection"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Visual geometry"),": Use detailed meshes only for rendering"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Physics update rate"),": Adjust based on object importance")),(0,t.yg)("h3",{id:"parallel-processing"},"Parallel Processing"),(0,t.yg)("p",null,"Modern simulation engines can utilize multiple cores:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Multi-threaded physics"),": Parallel physics calculations"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"GPU acceleration"),": Offload rendering and some physics to GPU"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Distributed simulation"),": Run multiple simulation instances")),(0,t.yg)("h2",{id:"quality-assessment"},"Quality Assessment"),(0,t.yg)("h3",{id:"simulation-quality-metrics"},"Simulation Quality Metrics"),(0,t.yg)("p",null,"Key metrics for evaluating simulation quality:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Kinematic accuracy"),": How well simulated motion matches real motion"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Dynamic accuracy"),": How well forces and torques are simulated"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Temporal consistency"),": Stability over time"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Computational efficiency"),": Performance vs. accuracy trade-offs")),(0,t.yg)("h3",{id:"validation-techniques"},"Validation Techniques"),(0,t.yg)("p",null,"Validating simulation accuracy:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Hardware-in-the-loop"),": Test with real sensors on simulated environments"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Cross-validation"),": Compare with other simulation platforms"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Real-world comparison"),": Compare results with physical experiments")),(0,t.yg)("h2",{id:"summary"},"Summary"),(0,t.yg)("p",null,"Simulation physics forms the foundation of effective robotics simulation. By understanding and properly configuring physics parameters, sensor models, and fidelity considerations, you can create simulations that effectively support robotics development and AI training while minimizing the reality gap."),(0,t.yg)("h2",{id:"references"},"References"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},"Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. IEEE/RSJ International Conference on Intelligent Robots and Systems."),(0,t.yg)("li",{parentName:"ol"},"NVIDIA Corporation. (2021). PhysX SDK Documentation. NVIDIA Developer."),(0,t.yg)("li",{parentName:"ol"},"Sadeghi, F., & Levine, S. (2017). CADRL: Learning to navigate safely with model-free reinforcement learning. Conference on Robot Learning."),(0,t.yg)("li",{parentName:"ol"},"James, S., Jaderberg, M., & Rusu, A. A. (2017). Domain randomization for transferring deep neural networks from simulation to the real world. IEEE/RSJ International Conference on Intelligent Robots and Systems.")))}y.isMDXComponent=!0},5680:(e,n,i)=>{i.d(n,{xA:()=>c,yg:()=>d});var a=i(6540);function t(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function o(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),i.push.apply(i,a)}return i}function l(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?o(Object(i),!0).forEach(function(n){t(e,n,i[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))})}return e}function s(e,n){if(null==e)return{};var i,a,t=function(e,n){if(null==e)return{};var i,a,t={},o=Object.keys(e);for(a=0;a<o.length;a++)i=o[a],n.indexOf(i)>=0||(t[i]=e[i]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)i=o[a],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var r=a.createContext({}),m=function(e){var n=a.useContext(r),i=n;return e&&(i="function"==typeof e?e(n):l(l({},n),e)),i},c=function(e){var n=m(e.components);return a.createElement(r.Provider,{value:n},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef(function(e,n){var i=e.components,t=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=m(i),p=t,d=u["".concat(r,".").concat(p)]||u[p]||y[p]||o;return i?a.createElement(d,l(l({ref:n},c),{},{components:i})):a.createElement(d,l({ref:n},c))});function d(e,n){var i=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=i.length,l=new Array(o);l[0]=p;var s={};for(var r in n)hasOwnProperty.call(n,r)&&(s[r]=n[r]);s.originalType=e,s[u]="string"==typeof e?e:t,l[1]=s;for(var m=2;m<o;m++)l[m]=i[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,i)}p.displayName="MDXCreateElement"},6515:(e,n,i)=>{i.d(n,{A:()=>l});var a=i(6540),t=i(53);const o={container:"container_keeZ",title:"title_3dyK",outcomesList:"outcomesList_zLvR",outcomeItem:"outcomeItem_f-i7",bullet:"bullet_Wb9q",highlighted:"highlighted_wRjA"},l=({outcomes:e,style:n="default"})=>e&&0!==e.length?a.createElement("div",{className:(0,t.A)("learning-outcome-container",o.container,o[n])},a.createElement("h3",{className:o.title},"Learning Outcomes"),a.createElement("ul",{className:o.outcomesList},e.map((e,n)=>a.createElement("li",{key:n,className:o.outcomeItem},a.createElement("span",{className:o.bullet},"\u2022")," ",e)))):null}}]);